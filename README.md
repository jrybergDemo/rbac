# Azure RBAC Terraform Configuration

This repository contains the configurations for deploying RBAC to Azure AD.

## Custom Role Definitions

Roles should be maintained within the [custom_roles.json](./terraform/custom_roles.json) file as generic templates. These roles will be imported into Terraform for each workflow and generated as subscription specific roles where the role name is `<Subscription Display Name> - <Custom Role Name>`.

**Example of Subscription Specific Role Name**

* `Contoso-Prod - Access Administrator`

Role definition IDs are not hardcoded into the [custom_roles.json](./terraform/custom_roles.json) file because they are automatically generated by Terraform using the `random_uuid.role_definition` resource.

## Custom Role Definition ID

The `random_uuid.role_definition` resource creates a unique GUID using a `for_each` loop which generates a map of objects as a key value pair.

The subscription specific role name is used as the key for each `random_uuid.role_definition` object which means that if Terraform has already created a particular subscription specific role in a past deployment then it will continue to use the pre-existing `random_uuid.role_definition` object, pulled from the Terraform state, as the role definition ID.

## Custom Role Definition Creation

Each custom role as defined within the [custom_roles.json](./terraform/custom_roles.json) file must provide `actions` permissions, it can optionally provide `not_actions` permissions, and it will have an assignable scope set to the Azure subscription of each workflow.

## Role Assignments

Each workflow allows role assignments for groups, service principals, and or users. For each type of role assignment, the principal object is pulled from Azure AD using the necessary resource (`azuread_group`, `azuread_service_principal`, or `azuread_user`).

All assignment objects and principal data source objects are merged into two separate variables, `local.principals` and `local.assignments`, which means that each principal name (group name, service principal name, and user name) must be unique across the three types.

**A collision of map keys during a `merge()` in Terraform will not result in an error it will only overwrite the first instance of the key's value with the second instance of the key's value.**

Using the `local.principals` and `local.assignments` variables, a nested for loop will create a list of role assignments which contains all assignments in each workflow called `local.role_assignments`.

### Role Assignment Properties

The nested for loop that creates the list of role assignments will build each assignment map object as shown below:

* **assignment_key**: The principal name, role name, and a truncated scope are merged together for later use as a `for_each` key in the `azurerm_role_assignment.assign` resource.
* **principal_id**: The assignment principal's object ID.
* **role_name**: There are two different formats for the name of a role depending on if the assignment `role_type` is `builtin` or `custom`.
  * **builtin**: the `role_name` from assignment is used without modification.
  * **custom**: the `role_name` from assignment is prefixed with the subscription display name (`<Subscription Display Name> - <Custom Role Name>`).
* **scope**: The assignment's scope.

### Role Assignment Key

The nested for loop that creates the list of role assignments will build each assignment with an `assignment_key` property in the following format:

`<Assignment Principal Name> - <Assignment Role Name> - <Truncated Assignment Scope>`

* **Assignment Principal Name**: the group name, service principal name, or user name for each assignment.
* **Assignment Role Name**: the role name for each assignment.
* **Truncated Assignment Scope**: the scope for each assignment truncated to the last two sections.

#### Truncated Assignment Scope

Due to limited functionality within Terraform, the method of truncating the assignment scope is more complex than it would traditionally be in a programming language. The full code for the `Truncated Assignment Scope` is shown below:

* `join("/", reverse(chunklist(reverse(split("/", assignment_object.scope)), 2)[0]))`

#### Truncated Assignment Scope Process

The truncation process of the assignment scope for use as part of the `assignment_key` is explained in the six steps below:

1. **Code**: `split("/", assignment_object.scope)`

   **Explanation**: `Split()` will generate a list of strings by applying a delimiter. The assignment scope string is split using a forward slash `/` as the delimiter.

2. **Code**: `reverse(split("/", assignment_object.scope))`

   **Explanation**: The list provided by `Split()` will have the left most values of the string at the beginning of the list and the right most values of the string at the end of the list. `Reverse()` will reverse the list so that values at the end will now be at the beginning.

3. **Code**: `chunklist(reverse(split("/", assignment_object.scope)), 2)`

   **Explanation**: `Chunklist()` will group items in a list by a given number. We now have a nested list where each group is a list of not more than two strings.

4. **Code**: `chunklist(reverse(split("/", assignment_object.scope)), 2)[0]`

   **Explanation**: Choose the first group of strings by using bracket notation `[]` where `0` is the first group of strings.

5. **Code**: `reverse(chunklist(reverse(split("/", assignment_object.scope)), 2)[0])`

   **Explanation**: `Reverse()` the list again to return the strings back to their original order.

6. **Code**: `join("/", reverse(chunklist(reverse(split("/", assignment_object.scope)), 2)[0]))`

   **Explanation**: `Join()` the list of strings together to form one string using a delimiter. The assignment scope string is joined using the forward slash `/` as the delimiter.

## Role Assignment Creation

Due to the `local.role_assignments` variable being a list Terraform will not allow it to be used with a `for_each` loop on a resource unless we convert it to a map so that it can provide a key for each instance of the resoure created.

We convert the `local.role_assignments` variable list into a map using a for expression nested inside a `for_each` loop which will use the `assignment_key` property as the key for each instance of the `azurerm_role_assignment.assign` resource created.
